// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: chat.sql

package database

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const addParticipant = `-- name: AddParticipant :exec
INSERT INTO chat_participants (chat_id, user_id, is_typing)
VALUES ($1, $2, FALSE)
ON CONFLICT (chat_id, user_id) DO NOTHING
`

type AddParticipantParams struct {
	ChatID int64 `json:"chat_id"`
	UserID int64 `json:"user_id"`
}

// AddParticipant
//
//	INSERT INTO chat_participants (chat_id, user_id, is_typing)
//	VALUES ($1, $2, FALSE)
//	ON CONFLICT (chat_id, user_id) DO NOTHING
func (q *Queries) AddParticipant(ctx context.Context, arg AddParticipantParams) error {
	_, err := q.db.Exec(ctx, addParticipant, arg.ChatID, arg.UserID)
	return err
}

const createEmptyChat = `-- name: CreateEmptyChat :one
INSERT INTO chats DEFAULT VALUES
RETURNING chat_id, last_message_id
`

type CreateEmptyChatRow struct {
	ChatID        int64  `json:"chat_id"`
	LastMessageID *int64 `json:"last_message_id"`
}

// CreateEmptyChat
//
//	INSERT INTO chats DEFAULT VALUES
//	RETURNING chat_id, last_message_id
func (q *Queries) CreateEmptyChat(ctx context.Context) (CreateEmptyChatRow, error) {
	row := q.db.QueryRow(ctx, createEmptyChat)
	var i CreateEmptyChatRow
	err := row.Scan(&i.ChatID, &i.LastMessageID)
	return i, err
}

const deleteChat = `-- name: DeleteChat :execrows

DELETE FROM chats
WHERE chat_id = $1
`

type DeleteChatParams struct {
	ChatID int64 `json:"chat_id"`
}

// optional: only author can delete
//
//	DELETE FROM chats
//	WHERE chat_id = $1
func (q *Queries) DeleteChat(ctx context.Context, arg DeleteChatParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteChat, arg.ChatID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteMessage = `-- name: DeleteMessage :execrows
DELETE FROM messages
WHERE message_id = $1
  AND sender_id = $2
`

type DeleteMessageParams struct {
	MessageID int64 `json:"message_id"`
	SenderID  int64 `json:"sender_id"`
}

// DeleteMessage
//
//	DELETE FROM messages
//	WHERE message_id = $1
//	  AND sender_id = $2
func (q *Queries) DeleteMessage(ctx context.Context, arg DeleteMessageParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteMessage, arg.MessageID, arg.SenderID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findDirectChatBetween = `-- name: FindDirectChatBetween :one
SELECT c.chat_id
FROM chats c
JOIN chat_participants cp1 ON cp1.chat_id = c.chat_id AND cp1.user_id = $1
JOIN chat_participants cp2 ON cp2.chat_id = c.chat_id AND cp2.user_id = $2
WHERE NOT EXISTS (
  SELECT 1
  FROM chat_participants cp3
  WHERE cp3.chat_id = c.chat_id
    AND cp3.user_id NOT IN ($1, $2)
)
LIMIT 1
`

type FindDirectChatBetweenParams struct {
	UserID   int64 `json:"user_id"`
	UserID_2 int64 `json:"user_id_2"`
}

// FindDirectChatBetween
//
//	SELECT c.chat_id
//	FROM chats c
//	JOIN chat_participants cp1 ON cp1.chat_id = c.chat_id AND cp1.user_id = $1
//	JOIN chat_participants cp2 ON cp2.chat_id = c.chat_id AND cp2.user_id = $2
//	WHERE NOT EXISTS (
//	  SELECT 1
//	  FROM chat_participants cp3
//	  WHERE cp3.chat_id = c.chat_id
//	    AND cp3.user_id NOT IN ($1, $2)
//	)
//	LIMIT 1
func (q *Queries) FindDirectChatBetween(ctx context.Context, arg FindDirectChatBetweenParams) (int64, error) {
	row := q.db.QueryRow(ctx, findDirectChatBetween, arg.UserID, arg.UserID_2)
	var chat_id int64
	err := row.Scan(&chat_id)
	return chat_id, err
}

const getChatByID = `-- name: GetChatByID :one
SELECT c.chat_id, c.last_message_id
FROM chats c
WHERE c.chat_id = $1
`

type GetChatByIDParams struct {
	ChatID int64 `json:"chat_id"`
}

type GetChatByIDRow struct {
	ChatID        int64  `json:"chat_id"`
	LastMessageID *int64 `json:"last_message_id"`
}

// GetChatByID
//
//	SELECT c.chat_id, c.last_message_id
//	FROM chats c
//	WHERE c.chat_id = $1
func (q *Queries) GetChatByID(ctx context.Context, arg GetChatByIDParams) (GetChatByIDRow, error) {
	row := q.db.QueryRow(ctx, getChatByID, arg.ChatID)
	var i GetChatByIDRow
	err := row.Scan(&i.ChatID, &i.LastMessageID)
	return i, err
}

const getNumberUnreadMessages = `-- name: GetNumberUnreadMessages :one
SELECT COUNT(*)::bigint
FROM messages m
JOIN chat_participants cp
  ON cp.chat_id = m.chat_id
WHERE cp.chat_id = $1
  AND cp.user_id = $2
  AND (
        cp.last_read_message_id IS NULL
        OR m.message_id > cp.last_read_message_id
      )
`

type GetNumberUnreadMessagesParams struct {
	ChatID int64 `json:"chat_id"`
	UserID int64 `json:"user_id"`
}

// GetNumberUnreadMessages
//
//	SELECT COUNT(*)::bigint
//	FROM messages m
//	JOIN chat_participants cp
//	  ON cp.chat_id = m.chat_id
//	WHERE cp.chat_id = $1
//	  AND cp.user_id = $2
//	  AND (
//	        cp.last_read_message_id IS NULL
//	        OR m.message_id > cp.last_read_message_id
//	      )
func (q *Queries) GetNumberUnreadMessages(ctx context.Context, arg GetNumberUnreadMessagesParams) (int64, error) {
	row := q.db.QueryRow(ctx, getNumberUnreadMessages, arg.ChatID, arg.UserID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const isUserInChat = `-- name: IsUserInChat :one

SELECT EXISTS (
  SELECT 1
  FROM chat_participants cp
  WHERE cp.chat_id = $1
    AND cp.user_id = $2
) AS is_participant
`

type IsUserInChatParams struct {
	ChatID int64 `json:"chat_id"`
	UserID int64 `json:"user_id"`
}

// only move forward
//
//	SELECT EXISTS (
//	  SELECT 1
//	  FROM chat_participants cp
//	  WHERE cp.chat_id = $1
//	    AND cp.user_id = $2
//	) AS is_participant
func (q *Queries) IsUserInChat(ctx context.Context, arg IsUserInChatParams) (bool, error) {
	row := q.db.QueryRow(ctx, isUserInChat, arg.ChatID, arg.UserID)
	var is_participant bool
	err := row.Scan(&is_participant)
	return is_participant, err
}

const listChatParticipants = `-- name: ListChatParticipants :many
SELECT
  cp.chat_id,
  u.pfp_url,
  u.user_id,
  u.first_name,
  u.last_name
FROM chat_participants cp
JOIN users u
  ON u.user_id = cp.user_id
WHERE cp.chat_id = ANY($1::bigint[])
`

type ListChatParticipantsParams struct {
	Column1 []int64 `json:"column_1"`
}

type ListChatParticipantsRow struct {
	ChatID    int64   `json:"chat_id"`
	PfpUrl    *string `json:"pfp_url"`
	UserID    int64   `json:"user_id"`
	FirstName string  `json:"first_name"`
	LastName  string  `json:"last_name"`
}

// ListChatParticipants
//
//	SELECT
//	  cp.chat_id,
//	  u.pfp_url,
//	  u.user_id,
//	  u.first_name,
//	  u.last_name
//	FROM chat_participants cp
//	JOIN users u
//	  ON u.user_id = cp.user_id
//	WHERE cp.chat_id = ANY($1::bigint[])
func (q *Queries) ListChatParticipants(ctx context.Context, arg ListChatParticipantsParams) ([]ListChatParticipantsRow, error) {
	rows, err := q.db.Query(ctx, listChatParticipants, arg.Column1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListChatParticipantsRow{}
	for rows.Next() {
		var i ListChatParticipantsRow
		if err := rows.Scan(
			&i.ChatID,
			&i.PfpUrl,
			&i.UserID,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChatsWithParticipant = `-- name: ListChatsWithParticipant :many
SELECT 
  c.chat_id,
  c.last_message_id,
  m.message_id,
  m.sender_id,
  c.created_at,
  -- all participants except the requesting user
  (
    SELECT ARRAY_AGG(cp2.user_id ORDER BY cp2.user_id)
    FROM chat_participants cp2
    WHERE cp2.chat_id = c.chat_id
      AND cp2.user_id <> $1
  ) AS other_participant_ids
FROM chats c
JOIN chat_participants cp 
  ON cp.chat_id = c.chat_id
 AND cp.user_id = $1
LEFT JOIN messages m 
  ON m.message_id = c.last_message_id
ORDER BY m.created_at DESC NULLS LAST
`

type ListChatsWithParticipantParams struct {
	UserID int64 `json:"user_id"`
}

type ListChatsWithParticipantRow struct {
	ChatID              int64       `json:"chat_id"`
	LastMessageID       *int64      `json:"last_message_id"`
	MessageID           *int64      `json:"message_id"`
	SenderID            *int64      `json:"sender_id"`
	CreatedAt           time.Time   `json:"created_at"`
	OtherParticipantIds interface{} `json:"other_participant_ids"`
}

// ListChatsWithParticipant
//
//	SELECT
//	  c.chat_id,
//	  c.last_message_id,
//	  m.message_id,
//	  m.sender_id,
//	  c.created_at,
//	  -- all participants except the requesting user
//	  (
//	    SELECT ARRAY_AGG(cp2.user_id ORDER BY cp2.user_id)
//	    FROM chat_participants cp2
//	    WHERE cp2.chat_id = c.chat_id
//	      AND cp2.user_id <> $1
//	  ) AS other_participant_ids
//	FROM chats c
//	JOIN chat_participants cp
//	  ON cp.chat_id = c.chat_id
//	 AND cp.user_id = $1
//	LEFT JOIN messages m
//	  ON m.message_id = c.last_message_id
//	ORDER BY m.created_at DESC NULLS LAST
func (q *Queries) ListChatsWithParticipant(ctx context.Context, arg ListChatsWithParticipantParams) ([]ListChatsWithParticipantRow, error) {
	rows, err := q.db.Query(ctx, listChatsWithParticipant, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListChatsWithParticipantRow{}
	for rows.Next() {
		var i ListChatsWithParticipantRow
		if err := rows.Scan(
			&i.ChatID,
			&i.LastMessageID,
			&i.MessageID,
			&i.SenderID,
			&i.CreatedAt,
			&i.OtherParticipantIds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChatsWithUser = `-- name: ListChatsWithUser :many
SELECT
  c.chat_id,

  m.message_id,
  m.sender_id,
  m.created_at,
  m.cypher_text
  
FROM chats c
JOIN chat_participants cp
  ON cp.chat_id = c.chat_id
 AND cp.user_id = $1
LEFT JOIN messages m
  ON m.message_id = c.last_message_id
ORDER BY
  m.created_at DESC NULLS LAST,
  c.last_message_id DESC,
  c.chat_id DESC
`

type ListChatsWithUserParams struct {
	UserID int64 `json:"user_id"`
}

type ListChatsWithUserRow struct {
	ChatID     int64              `json:"chat_id"`
	MessageID  *int64             `json:"message_id"`
	SenderID   *int64             `json:"sender_id"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	CypherText []byte             `json:"cypher_text"`
}

// ListChatsWithUser
//
//	SELECT
//	  c.chat_id,
//
//	  m.message_id,
//	  m.sender_id,
//	  m.created_at,
//	  m.cypher_text
//
//	FROM chats c
//	JOIN chat_participants cp
//	  ON cp.chat_id = c.chat_id
//	 AND cp.user_id = $1
//	LEFT JOIN messages m
//	  ON m.message_id = c.last_message_id
//	ORDER BY
//	  m.created_at DESC NULLS LAST,
//	  c.last_message_id DESC,
//	  c.chat_id DESC
func (q *Queries) ListChatsWithUser(ctx context.Context, arg ListChatsWithUserParams) ([]ListChatsWithUserRow, error) {
	rows, err := q.db.Query(ctx, listChatsWithUser, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListChatsWithUserRow{}
	for rows.Next() {
		var i ListChatsWithUserRow
		if err := rows.Scan(
			&i.ChatID,
			&i.MessageID,
			&i.SenderID,
			&i.CreatedAt,
			&i.CypherText,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeParticipant = `-- name: RemoveParticipant :execrows
DELETE FROM chat_participants
WHERE chat_id = $1 AND user_id = $2
`

type RemoveParticipantParams struct {
	ChatID int64 `json:"chat_id"`
	UserID int64 `json:"user_id"`
}

// RemoveParticipant
//
//	DELETE FROM chat_participants
//	WHERE chat_id = $1 AND user_id = $2
func (q *Queries) RemoveParticipant(ctx context.Context, arg RemoveParticipantParams) (int64, error) {
	result, err := q.db.Exec(ctx, removeParticipant, arg.ChatID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const setLastReadMessage = `-- name: SetLastReadMessage :execrows
UPDATE chat_participants cp
SET last_read_message_id = $1,
    last_read_at = now()
WHERE cp.chat_id = $2
  AND cp.user_id = $3
  AND (cp.last_read_message_id IS NULL OR cp.last_read_message_id < $1)
`

type SetLastReadMessageParams struct {
	LastReadMessageID *int64 `json:"last_read_message_id"`
	ChatID            int64  `json:"chat_id"`
	UserID            int64  `json:"user_id"`
}

// SetLastReadMessage
//
//	UPDATE chat_participants cp
//	SET last_read_message_id = $1,
//	    last_read_at = now()
//	WHERE cp.chat_id = $2
//	  AND cp.user_id = $3
//	  AND (cp.last_read_message_id IS NULL OR cp.last_read_message_id < $1)
func (q *Queries) SetLastReadMessage(ctx context.Context, arg SetLastReadMessageParams) (int64, error) {
	result, err := q.db.Exec(ctx, setLastReadMessage, arg.LastReadMessageID, arg.ChatID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const setTypingStatus = `-- name: SetTypingStatus :execrows
UPDATE chat_participants cp
SET is_typing = $1
WHERE cp.chat_id = $2
  AND cp.user_id = $3
`

type SetTypingStatusParams struct {
	IsTyping bool  `json:"is_typing"`
	ChatID   int64 `json:"chat_id"`
	UserID   int64 `json:"user_id"`
}

// SetTypingStatus
//
//	UPDATE chat_participants cp
//	SET is_typing = $1
//	WHERE cp.chat_id = $2
//	  AND cp.user_id = $3
func (q *Queries) SetTypingStatus(ctx context.Context, arg SetTypingStatusParams) (int64, error) {
	result, err := q.db.Exec(ctx, setTypingStatus, arg.IsTyping, arg.ChatID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateChatLastMessage = `-- name: UpdateChatLastMessage :exec
UPDATE chats
SET last_message_id = $1
WHERE chat_id = $2
`

type UpdateChatLastMessageParams struct {
	LastMessageID *int64 `json:"last_message_id"`
	ChatID        int64  `json:"chat_id"`
}

// UpdateChatLastMessage
//
//	UPDATE chats
//	SET last_message_id = $1
//	WHERE chat_id = $2
func (q *Queries) UpdateChatLastMessage(ctx context.Context, arg UpdateChatLastMessageParams) error {
	_, err := q.db.Exec(ctx, updateChatLastMessage, arg.LastMessageID, arg.ChatID)
	return err
}
