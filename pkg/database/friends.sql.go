// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: friends.sql

package database

import (
	"context"
	"time"
)

const areUsersFriends = `-- name: AreUsersFriends :one
SELECT EXISTS (
  SELECT 1
  FROM user_friendships AS uf
  WHERE (uf.user_id, uf.friend_id) IN (($1, $2), ($2, $1))
) AS are_friends
`

type AreUsersFriendsParams struct {
	UserID   int64 `json:"user_id"`
	UserID_2 int64 `json:"user_id_2"`
}

// AreUsersFriends
//
//	SELECT EXISTS (
//	  SELECT 1
//	  FROM user_friendships AS uf
//	  WHERE (uf.user_id, uf.friend_id) IN (($1, $2), ($2, $1))
//	) AS are_friends
func (q *Queries) AreUsersFriends(ctx context.Context, arg AreUsersFriendsParams) (bool, error) {
	row := q.db.QueryRow(ctx, areUsersFriends, arg.UserID, arg.UserID_2)
	var are_friends bool
	err := row.Scan(&are_friends)
	return are_friends, err
}

const createFriendRequest = `-- name: CreateFriendRequest :one
INSERT INTO friend_requests (sender_id, receiver_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
RETURNING request_id, sender_id, receiver_id
`

type CreateFriendRequestParams struct {
	SenderID   int64 `json:"sender_id"`
	ReceiverID int64 `json:"receiver_id"`
}

// CreateFriendRequest
//
//	INSERT INTO friend_requests (sender_id, receiver_id)
//	VALUES ($1, $2)
//	ON CONFLICT DO NOTHING
//	RETURNING request_id, sender_id, receiver_id
func (q *Queries) CreateFriendRequest(ctx context.Context, arg CreateFriendRequestParams) (FriendRequest, error) {
	row := q.db.QueryRow(ctx, createFriendRequest, arg.SenderID, arg.ReceiverID)
	var i FriendRequest
	err := row.Scan(&i.RequestID, &i.SenderID, &i.ReceiverID)
	return i, err
}

const createFriendship = `-- name: CreateFriendship :exec
INSERT INTO user_friendships (user_id, friend_id)
VALUES ($1, $2), ($2, $1)
ON CONFLICT DO NOTHING
`

type CreateFriendshipParams struct {
	UserID   int64 `json:"user_id"`
	FriendID int64 `json:"friend_id"`
}

// CreateFriendship
//
//	INSERT INTO user_friendships (user_id, friend_id)
//	VALUES ($1, $2), ($2, $1)
//	ON CONFLICT DO NOTHING
func (q *Queries) CreateFriendship(ctx context.Context, arg CreateFriendshipParams) error {
	_, err := q.db.Exec(ctx, createFriendship, arg.UserID, arg.FriendID)
	return err
}

const deleteFriendRequest = `-- name: DeleteFriendRequest :execrows
DELETE FROM friend_requests
WHERE request_id = $1
  AND sender_id = $2
`

type DeleteFriendRequestParams struct {
	RequestID int64 `json:"request_id"`
	SenderID  int64 `json:"sender_id"`
}

// DeleteFriendRequest
//
//	DELETE FROM friend_requests
//	WHERE request_id = $1
//	  AND sender_id = $2
func (q *Queries) DeleteFriendRequest(ctx context.Context, arg DeleteFriendRequestParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteFriendRequest, arg.RequestID, arg.SenderID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const doesFriendRequestExist = `-- name: DoesFriendRequestExist :one
SELECT EXISTS (
  SELECT 1
  FROM friend_requests
  WHERE (sender_id = $1 AND receiver_id = $2)
     OR (sender_id = $2 AND receiver_id = $1)
) AS friend_request_exists
`

type DoesFriendRequestExistParams struct {
	SenderID   int64 `json:"sender_id"`
	ReceiverID int64 `json:"receiver_id"`
}

// DoesFriendRequestExist
//
//	SELECT EXISTS (
//	  SELECT 1
//	  FROM friend_requests
//	  WHERE (sender_id = $1 AND receiver_id = $2)
//	     OR (sender_id = $2 AND receiver_id = $1)
//	) AS friend_request_exists
func (q *Queries) DoesFriendRequestExist(ctx context.Context, arg DoesFriendRequestExistParams) (bool, error) {
	row := q.db.QueryRow(ctx, doesFriendRequestExist, arg.SenderID, arg.ReceiverID)
	var friend_request_exists bool
	err := row.Scan(&friend_request_exists)
	return friend_request_exists, err
}

const getFriendRequestByID = `-- name: GetFriendRequestByID :one
SELECT request_id, sender_id, receiver_id
FROM friend_requests
WHERE request_id = $1
`

type GetFriendRequestByIDParams struct {
	RequestID int64 `json:"request_id"`
}

// GetFriendRequestByID
//
//	SELECT request_id, sender_id, receiver_id
//	FROM friend_requests
//	WHERE request_id = $1
func (q *Queries) GetFriendRequestByID(ctx context.Context, arg GetFriendRequestByIDParams) (FriendRequest, error) {
	row := q.db.QueryRow(ctx, getFriendRequestByID, arg.RequestID)
	var i FriendRequest
	err := row.Scan(&i.RequestID, &i.SenderID, &i.ReceiverID)
	return i, err
}

const getPendingRequestBetween = `-- name: GetPendingRequestBetween :one
SELECT request_id, sender_id, receiver_id
FROM friend_requests
LIMIT 1
`

// GetPendingRequestBetween
//
//	SELECT request_id, sender_id, receiver_id
//	FROM friend_requests
//	LIMIT 1
func (q *Queries) GetPendingRequestBetween(ctx context.Context) (FriendRequest, error) {
	row := q.db.QueryRow(ctx, getPendingRequestBetween)
	var i FriendRequest
	err := row.Scan(&i.RequestID, &i.SenderID, &i.ReceiverID)
	return i, err
}

const getUserByRequestID = `-- name: GetUserByRequestID :one
SELECT sender_id
FROM friend_requests
WHERE request_id = $1
`

type GetUserByRequestIDParams struct {
	RequestID int64 `json:"request_id"`
}

// GetUserByRequestID
//
//	SELECT sender_id
//	FROM friend_requests
//	WHERE request_id = $1
func (q *Queries) GetUserByRequestID(ctx context.Context, arg GetUserByRequestIDParams) (int64, error) {
	row := q.db.QueryRow(ctx, getUserByRequestID, arg.RequestID)
	var sender_id int64
	err := row.Scan(&sender_id)
	return sender_id, err
}

const listAllFriends = `-- name: ListAllFriends :many
SELECT u.user_id, u.pfp_url, u.display_name, u.first_name, u.last_name, f.friendship_ts
FROM user_friendships f
JOIN users u ON u.user_id = f.friend_id
WHERE f.user_id = $1
ORDER BY f.friendship_ts DESC
`

type ListAllFriendsParams struct {
	UserID int64 `json:"user_id"`
}

type ListAllFriendsRow struct {
	UserID       int64     `json:"user_id"`
	PfpUrl       *string   `json:"pfp_url"`
	DisplayName  string    `json:"display_name"`
	FirstName    string    `json:"first_name"`
	LastName     string    `json:"last_name"`
	FriendshipTs time.Time `json:"friendship_ts"`
}

// ListAllFriends
//
//	SELECT u.user_id, u.pfp_url, u.display_name, u.first_name, u.last_name, f.friendship_ts
//	FROM user_friendships f
//	JOIN users u ON u.user_id = f.friend_id
//	WHERE f.user_id = $1
//	ORDER BY f.friendship_ts DESC
func (q *Queries) ListAllFriends(ctx context.Context, arg ListAllFriendsParams) ([]ListAllFriendsRow, error) {
	rows, err := q.db.Query(ctx, listAllFriends, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllFriendsRow{}
	for rows.Next() {
		var i ListAllFriendsRow
		if err := rows.Scan(
			&i.UserID,
			&i.PfpUrl,
			&i.DisplayName,
			&i.FirstName,
			&i.LastName,
			&i.FriendshipTs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIncomingFriendRequests = `-- name: ListIncomingFriendRequests :many
SELECT request_id, sender_id, receiver_id
FROM friend_requests
WHERE receiver_id = $1
ORDER BY request_id DESC
LIMIT $2 OFFSET $3
`

type ListIncomingFriendRequestsParams struct {
	ReceiverID int64 `json:"receiver_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

// ListIncomingFriendRequests
//
//	SELECT request_id, sender_id, receiver_id
//	FROM friend_requests
//	WHERE receiver_id = $1
//	ORDER BY request_id DESC
//	LIMIT $2 OFFSET $3
func (q *Queries) ListIncomingFriendRequests(ctx context.Context, arg ListIncomingFriendRequestsParams) ([]FriendRequest, error) {
	rows, err := q.db.Query(ctx, listIncomingFriendRequests, arg.ReceiverID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FriendRequest{}
	for rows.Next() {
		var i FriendRequest
		if err := rows.Scan(&i.RequestID, &i.SenderID, &i.ReceiverID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOutgoingFriendRequests = `-- name: ListOutgoingFriendRequests :many
SELECT request_id, sender_id, receiver_id
FROM friend_requests
WHERE sender_id = $1
ORDER BY request_id DESC
LIMIT $2 OFFSET $3
`

type ListOutgoingFriendRequestsParams struct {
	SenderID int64 `json:"sender_id"`
	Limit    int32 `json:"limit"`
	Offset   int32 `json:"offset"`
}

// ListOutgoingFriendRequests
//
//	SELECT request_id, sender_id, receiver_id
//	FROM friend_requests
//	WHERE sender_id = $1
//	ORDER BY request_id DESC
//	LIMIT $2 OFFSET $3
func (q *Queries) ListOutgoingFriendRequests(ctx context.Context, arg ListOutgoingFriendRequestsParams) ([]FriendRequest, error) {
	rows, err := q.db.Query(ctx, listOutgoingFriendRequests, arg.SenderID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FriendRequest{}
	for rows.Next() {
		var i FriendRequest
		if err := rows.Scan(&i.RequestID, &i.SenderID, &i.ReceiverID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReceivedFriendRequestsWithUser = `-- name: ListReceivedFriendRequestsWithUser :many
SELECT fr.request_id,
       fr.sender_id,
       fr.receiver_id,
       u.user_id,
       u.display_name,
       u.pfp_url
FROM friend_requests fr
JOIN users u ON u.user_id = fr.sender_id
WHERE fr.receiver_id = $1
`

type ListReceivedFriendRequestsWithUserParams struct {
	ReceiverID int64 `json:"receiver_id"`
}

type ListReceivedFriendRequestsWithUserRow struct {
	RequestID   int64   `json:"request_id"`
	SenderID    int64   `json:"sender_id"`
	ReceiverID  int64   `json:"receiver_id"`
	UserID      int64   `json:"user_id"`
	DisplayName string  `json:"display_name"`
	PfpUrl      *string `json:"pfp_url"`
}

// ListReceivedFriendRequestsWithUser
//
//	SELECT fr.request_id,
//	       fr.sender_id,
//	       fr.receiver_id,
//	       u.user_id,
//	       u.display_name,
//	       u.pfp_url
//	FROM friend_requests fr
//	JOIN users u ON u.user_id = fr.sender_id
//	WHERE fr.receiver_id = $1
func (q *Queries) ListReceivedFriendRequestsWithUser(ctx context.Context, arg ListReceivedFriendRequestsWithUserParams) ([]ListReceivedFriendRequestsWithUserRow, error) {
	rows, err := q.db.Query(ctx, listReceivedFriendRequestsWithUser, arg.ReceiverID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListReceivedFriendRequestsWithUserRow{}
	for rows.Next() {
		var i ListReceivedFriendRequestsWithUserRow
		if err := rows.Scan(
			&i.RequestID,
			&i.SenderID,
			&i.ReceiverID,
			&i.UserID,
			&i.DisplayName,
			&i.PfpUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSentFriendRequestsWithUser = `-- name: ListSentFriendRequestsWithUser :many
SELECT fr.request_id,
       fr.sender_id,
       fr.receiver_id,
       u.user_id,
       u.display_name,
       u.pfp_url
FROM friend_requests fr
JOIN users u ON u.user_id = fr.receiver_id
WHERE fr.sender_id = $1
`

type ListSentFriendRequestsWithUserParams struct {
	SenderID int64 `json:"sender_id"`
}

type ListSentFriendRequestsWithUserRow struct {
	RequestID   int64   `json:"request_id"`
	SenderID    int64   `json:"sender_id"`
	ReceiverID  int64   `json:"receiver_id"`
	UserID      int64   `json:"user_id"`
	DisplayName string  `json:"display_name"`
	PfpUrl      *string `json:"pfp_url"`
}

// ListSentFriendRequestsWithUser
//
//	SELECT fr.request_id,
//	       fr.sender_id,
//	       fr.receiver_id,
//	       u.user_id,
//	       u.display_name,
//	       u.pfp_url
//	FROM friend_requests fr
//	JOIN users u ON u.user_id = fr.receiver_id
//	WHERE fr.sender_id = $1
func (q *Queries) ListSentFriendRequestsWithUser(ctx context.Context, arg ListSentFriendRequestsWithUserParams) ([]ListSentFriendRequestsWithUserRow, error) {
	rows, err := q.db.Query(ctx, listSentFriendRequestsWithUser, arg.SenderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSentFriendRequestsWithUserRow{}
	for rows.Next() {
		var i ListSentFriendRequestsWithUserRow
		if err := rows.Scan(
			&i.RequestID,
			&i.SenderID,
			&i.ReceiverID,
			&i.UserID,
			&i.DisplayName,
			&i.PfpUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
